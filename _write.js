var qs = require('querystring')
var http = require('http')
var https = require('https')
var FormData = require('@brianleroux/form-data')
var url = require('url')

module.exports = function _write(httpMethod, options, callback) {

  // deep copy options if no buffers being passed in
  let formopts = options.data || options.body
  let notplain = k => typeof formopts[k] != 'string'
  let basic = formopts && Object.keys(formopts).some(notplain) === false
  if (basic) {
    options = JSON.parse(JSON.stringify(options))
  }

  // alias body = data
  if (options.body && !options.data) {
    options.data = options.body
  }

  // require options.url or fail noisily
  if (!options.url) {
    throw Error('options.url required')
  }

  // setup promise if there is no callback
  var promise
  if (!callback) {
    promise = new Promise(function(res, rej) {
      callback = function(err, result) {
        err ? rej(err) : res(result)
      }
    })
  }

  // parse out the options from options.url
  var opts = url.parse(options.url)
  var method = opts.protocol === 'https:'? https.request : http.request
  var defaultContentType = 'application/json; charset=utf-8'

  // add timeout
  if (options.timeout) {
    opts.timeout = timeout
  }

  // wrangle defaults
  opts.method = httpMethod
  opts.headers = options.headers || {}
  opts.headers['user-agent'] = opts.headers['user-agent'] || opts.headers['User-Agent'] || 'tiny-http'
  opts.headers['content-type'] = opts.headers['content-type'] || opts.headers['Content-Type'] || defaultContentType

  // default to regular POST body (url enc)
  var postData = qs.stringify(options.data || {})

  function is(headers, type) {
    var regex = type instanceof RegExp
    var upper = headers['Content-Type']
    var lower = headers['content-type']
    var isU = upper && (regex ? upper.match(type) : upper.startsWith(type))
    var isL = lower && (regex ? lower.match(type) : lower.startsWith(type))
    return isU || isL
  }

  // if we're posting JSON stringify options.data
  var isJSON = is(opts.headers, /^application\/.*json/)
  if (isJSON) {
    postData = JSON.stringify(options.data || {})
  }

    // if we're doing a application/x-www-form-urlencoded to upload files
  // we'll overload `method` and use the custom form-data submit instead of http.request
  var isUrlEncoded = is(opts.headers, 'application/x-www-form-urlencoded')
  if (isUrlEncoded) {
    postData = Object.keys(options.data)
      .map(k => `${encodeURI(k)}=${encodeURI(options.data[k])}`)
      .join('&')
  }

  // ensure we know the len ~after~ we set the postData
  opts.headers['Content-Length'] = Buffer.byteLength(postData)

  // if we're doing a mutipart/form-data to upload files
  // we'll overload `method` and use the custom form-data submit instead of http.request
  var isMultipart = is(opts.headers, 'multipart/form-data')
  if (isMultipart) {
    method = function _multiPartFormDataPost(params, streamback) {
      var form = new FormData
      Object.keys(options.data).forEach(k=> {
        form.append(k, options.data[k])
      })
      // remove stuff generated by form.submit
      delete opts.headers['Content-Type']
      delete opts.headers['content-type']
      delete opts.headers['Content-Length']
      delete opts.headers['content-length']
      // perform a multipart/form-data POST request
      form.submit(opts, function _submit(err, res) {
        if (err) callback(err)
        else streamback(res)
      })
    }
  }

  // make a request
  var req = method(opts, function(res) {
    var raw = [] // keep our buffers here
    var ok = res.statusCode >= 200 && res.statusCode < 303

    res.on('data', function _data(chunk) {
      raw.push(chunk)
    })

    res.on('end', function _end() {
      var err = null
      var result = null

      try {
        result = Buffer.concat(raw)

        if (!options.buffer) {
          var isJSON = is(res.headers, /^application\/.*json/)
          var strRes = result.toString()
          result = strRes && isJSON ? JSON.parse(strRes) : strRes
        }
      }
      catch (e) {
        err = e
      }

      if (!ok) {
        err = Error(httpMethod + ' failed with: ' + res.statusCode)
        err.raw = res
        err.body = result
        err.statusCode = res.statusCode
        callback(err)
      }
      else {
        callback(err, {body:result, headers:res.headers})
      }
    })
  })

  if (!isMultipart) {
    req.on('error', callback)
    req.write(postData)
    req.end()
  }

  return promise
}
